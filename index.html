<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Kaleidoscope ‚Äî Edge Micro-Docks + Full Controls</title>
<style>
  :root{
    --fg:#eafff4; --muted:#9fd0c0; --line:#0f1a18;
    --pill:#07120e; --glow:#35ff9a; --glow2:#7bffc8;
    --rad:12px; --gap:8px;
    --sideW: 260px; --edgeH: 84px;
    --pad: max(10px, env(safe-area-inset-left,0px));
    --padR:max(10px, env(safe-area-inset-right,0px));
    --padT:max(10px, env(safe-area-inset-top,0px));
    --padB:max(10px, env(safe-area-inset-bottom,0px));
  }
  html,body{margin:0;height:100%;background:#000;color:var(--fg);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden}
  *{box-sizing:border-box;-webkit-user-select:none;user-select:none;-webkit-touch-callout:none}
  body{touch-action:manipulation}

  /* Center visual ‚Äî your kaleidoscope */
  #stage{position:fixed; inset:0; width:100vw; height:100vh; z-index:0; display:block; background:#000}

  .pill{
    background:var(--pill); color:var(--fg); border:1px solid var(--line);
    border-radius:999px; padding:10px; font-size:18px; cursor:pointer;
    box-shadow:0 0 10px var(--glow), 0 0 20px var(--glow2);
  }
  .mini{
    background:linear-gradient(180deg,#081411,#0a1714);
    border:1px solid var(--line); border-radius:var(--rad);
    box-shadow:0 0 0 1px #0a1714, 0 0 18px rgba(53,255,154,.18);
    padding:10px; color:var(--fg); font-size:13px;
  }
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  label{display:grid; gap:4px; font-size:12px; color:var(--muted)}
  input[type=range]{width:140px}

  /* Top */
  .dockTop{position:fixed; z-index:10; left:50%; transform:translateX(-50%); top:var(--padT)}
  .topPanel{position:absolute; left:50%; transform:translate(-50%,8px); top:42px; width:min(96vw,560px); height:var(--edgeH); display:none}
  .dockTop.open .topPanel{display:block}

  /* Bottom */
  .dockBottom{position:fixed; z-index:10; left:50%; transform:translateX(-50%); bottom:var(--padB)}
  .botPanel{position:absolute; left:50%; transform:translate(-50%,-8px); bottom:42px; width:min(96vw,620px); height:var(--edgeH); display:none}
  .dockBottom.open .botPanel{display:block}

  /* Left */
  .dockLeft{position:fixed; z-index:10; left:var(--pad); top:50%; transform:translateY(-50%)}
  .leftPanel{position:absolute; left:calc(var(--pad) + 42px); top:50%; transform:translateY(-50%); width:var(--sideW); display:none}
  .dockLeft.open .leftPanel{display:block}

  /* Right */
  .dockRight{position:fixed; z-index:10; right:var(--padR); top:50%; transform:translateY(-50%)}
  .rightPanel{position:absolute; right:calc(var(--padR) + 42px); top:50%; transform:translateY(-50%); width:var(--sideW); display:none}
  .dockRight.open .rightPanel{display:block}

  @media (max-width:520px){
    :root{ --sideW: 82vw; --edgeH: 92px }
    input[type=range]{width:120px}
  }
</style>
</head>
<body>

<!-- CENTER CANVAS (WebGL kaleidoscope renders here) -->
<canvas id="stage"></canvas>

<!-- TOP micro-dock: wedges + mix, and mode buttons -->
<div class="dockTop" id="dockTop">
  <button class="pill" data-toggle="dockTop">üîº</button>
  <div class="mini topPanel">
    <div class="row">
      <label>Wedges<input id="wedges" type="range" min="2" max="16" step="1" value="8"></label>
      <label>Mix<input id="mix" type="range" min="0" max="1" step="0.001" value="0.5"></label>
      <div class="row">
        <button id="modeK" class="pill" title="Kaleidoscope" style="padding:6px 10px">‚ú≥Ô∏è</button>
        <button id="modeM" class="pill" title="Mirror" style="padding:6px 10px">ü™û</button>
      </div>
    </div>
  </div>
</div>

<!-- BOTTOM micro-dock: deck loads + snapshot + record -->
<div class="dockBottom" id="dockBottom">
  <button class="pill" data-toggle="dockBottom">üîΩ</button>
  <div class="mini botPanel">
    <div class="row">
      <label>Deck A<input id="pickA" type="file" accept="image/*,video/*"></label>
      <label>Deck B<input id="pickB" type="file" accept="image/*,video/*"></label>
      <button id="snap" class="pill" title="Snapshot">üì∏</button>
      <button id="rec" class="pill" title="Record">‚è∫</button>
    </div>
    <div id="recLamp" style="width:10px;height:10px;border-radius:50%;background:#193b30;display:inline-block;margin-left:8px"></div>
  </div>
</div>

<!-- LEFT micro-dock: transform -->
<div class="dockLeft" id="dockLeft">
  <button class="pill" data-toggle="dockLeft">‚óÄ</button>
  <div class="mini leftPanel">
    <label>Zoom<input id="zoom" type="range" min="0.2" max="6" step="0.001" value="1"></label>
    <label>Rotate<input id="rot" type="range" min="-3.1416" max="3.1416" step="0.0005" value="0"></label>
    <label>Pan X<input id="panx" type="range" min="-1" max="1" step="0.0005" value="0"></label>
    <label>Pan Y<input id="pany" type="range" min="-1" max="1" step="0.0005" value="0"></label>
    <label>Spin<input id="spinHz" type="range" min="-0.05" max="0.05" step="0.0001" value="0"></label>
  </div>
</div>

<!-- RIGHT micro-dock: ripple -->
<div class="dockRight" id="dockRight">
  <button class="pill" data-toggle="dockRight">‚ñ∂</button>
  <div class="mini rightPanel">
    <label>Ripple Amt<input id="rAmp" type="range" min="0" max="0.6" step="0.001" value="0.20"></label>
    <label>Frequency<input id="rFreq" type="range" min="0.5" max="12" step="0.01" value="6"></label>
    <label>Speed<input id="rSpeed" type="range" min="0" max="6" step="0.01" value="1.5"></label>
  </div>
</div>

<script>
/* ===== UI: edge micro-panels toggle, keep center clear ===== */
document.querySelectorAll('[data-toggle]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const id = btn.getAttribute('data-toggle');
    const dock = document.getElementById(id);
    const open = dock.classList.toggle('open');
    document.querySelectorAll('.dockTop,.dockBottom,.dockLeft,.dockRight').forEach(d=>{
      if(d!==dock) d.classList.remove('open');
    });
  });
});

/* ===== Prevent iOS copy/select bars ===== */
addEventListener('contextmenu', e=> e.preventDefault(), {passive:false});
addEventListener('selectstart', e=> e.preventDefault(), {passive:false});
addEventListener('gesturestart', e=> e.preventDefault(), {passive:false});

/* ===== WebGL Kaleidoscope Engine (with A/B decks, crossfade, ripple, transform) ===== */
(function(){
  const $ = id=>document.getElementById(id);
  const cv = $('stage');

  const UI = {
    mix:$('mix'), wedges:$('wedges'),
    zoom:$('zoom'), rot:$('rot'), panx:$('panx'), pany:$('pany'), spinHz:$('spinHz'),
    rAmp:$('rAmp'), rFreq:$('rFreq'), rSpeed:$('rSpeed'),
    modeK:$('modeK'), modeM:$('modeM'),
    pickA:$('pickA'), pickB:$('pickB'),
    snap:$('snap'), rec:$('rec'), recLamp:$('recLamp')
  };

  const state = {
    mix:+UI.mix.value, wedges:+UI.wedges.value,
    zoom:+UI.zoom.value, rot:+UI.rot.value, panx:+UI.panx.value, pany:+UI.pany.value, spinHz:+UI.spinHz.value,
    rAmp:+UI.rAmp.value, rFreq:+UI.rFreq.value, rSpeed:+UI.rSpeed.value,
    mode:0
  };
  ['mix','wedges','zoom','rot','panx','pany','spinHz','rAmp','rFreq','rSpeed']
   .forEach(k=> UI[k].addEventListener('input', ()=> state[k]=+UI[k].value));
  UI.modeK.onclick = ()=> state.mode=0;
  UI.modeM.onclick = ()=> state.mode=1;

  function fit(){
    const dpr = Math.min(window.devicePixelRatio||1, 2);
    const w = Math.floor(innerWidth*dpr), h = Math.floor(innerHeight*dpr);
    if(cv.width!==w||cv.height!==h){ cv.width=w; cv.height=h; }
  }
  addEventListener('resize', fit);

  // Decks (images/videos ‚Üí textures)
  const deckA = {img:null, vid:null, cvs:document.createElement('canvas'), ctx:null};
  const deckB = {img:null, vid:null, cvs:document.createElement('canvas'), ctx:null};
  deckA.ctx = deckA.cvs.getContext('2d'); deckB.ctx = deckB.cvs.getContext('2d');

  function loadTo(deck, file){
    if(!file) return;
    if(file.type.startsWith('video')){
      const v=document.createElement('video');
      v.muted=true; v.loop=true; v.playsInline=true; v.autoplay=true;
      v.onloadeddata=()=>{ v.play().catch(()=>{}); deck.vid=v; deck.img=null; };
      v.src=URL.createObjectURL(file);
    }else{
      const img=new Image();
      img.onload=()=>{ deck.img=img; deck.vid=null; };
      img.src=URL.createObjectURL(file);
    }
  }
  UI.pickA.onchange = e=>{ loadTo(deckA, e.target.files[0]); e.target.value=''; };
  UI.pickB.onchange = e=>{ loadTo(deckB, e.target.files[0]); e.target.value=''; };

  function tryGL(ver){ try{ return cv.getContext(ver,{preserveDrawingBuffer:true,antialias:true}); }catch{return null;} }
  let gl = tryGL('webgl2') || tryGL('webgl');
  if(!gl){ alert('WebGL not supported'); return; }

  const vs = `
    attribute vec2 aPos; varying vec2 vUv;
    void main(){ vUv=(aPos+1.0)*0.5; gl_Position=vec4(aPos,0.,1.); }
  `;
  const fs = `
    precision highp float; varying vec2 vUv;
    uniform sampler2D texA, texB; uniform float mixAB;
    uniform vec2 resolution; uniform float time;
    uniform int mode; uniform float wedges; uniform float zoom, rot; uniform vec2 pan;
    uniform float rAmp, rFreq, rSpeed; uniform float imgSpin;
    mat2 R(float a){ float c=cos(a), s=sin(a); return mat2(c,-s,s,c); }
    vec2 rotAround(vec2 uv, float a){ vec2 d=uv-0.5; d=R(a)*d; return d+0.5; }
    vec2 userUV(vec2 p){
      vec2 q = R(rot)*p;
      float r = length(q);
      float wave = sin(r*rFreq - time*rSpeed);
      q *= (1.0 + wave * rAmp);
      q *= zoom; q += pan;
      return q*0.5 + 0.5;
    }
    vec3 sampleMix(vec2 uv){
      vec2 suv = rotAround(uv, imgSpin);
      vec4 a=texture2D(texA,suv), b=texture2D(texB,suv);
      return mix(a,b,clamp(mixAB,0.0,1.0)).rgb;
    }
    vec3 kaleido(){
      vec2 n=vUv*2.0-1.0; n.x *= resolution.x/resolution.y;
      float ang=atan(n.y,n.x), r=length(n);
      float sector = 6.28318530718 / max(2.0, wedges);
      float a = mod(ang, sector); if(a>0.5*sector) a = sector - a;
      vec2 dir = vec2(cos(a), sin(a));
      return sampleMix(userUV(r*dir));
    }
    vec3 mirrorFX(){
      vec2 n=vUv*2.0-1.0; n.x *= resolution.x/resolution.y;
      vec2 p = vec2(abs(n.x), n.y);
      return sampleMix(userUV(p));
    }
    void main(){
      vec3 col = (mode==0)? kaleido() : mirrorFX();
      gl_FragColor = vec4(col,1.0);
    }
  `;
  function sh(t,s){ const o=gl.createShader(t); gl.shaderSource(o,s); gl.compileShader(o); if(!gl.getShaderParameter(o,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(o); return o; }
  const pr=gl.createProgram(); gl.attachShader(pr, sh(gl.VERTEX_SHADER,vs)); gl.attachShader(pr, sh(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(pr);
  if(!gl.getProgramParameter(pr,gl.LINK_STATUS)) throw gl.getProgramInfoLog(pr);
  gl.useProgram(pr);

  const quad=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,quad);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1, 1,-1, -1,1, 1,-1, 1,1, -1,1]),gl.STATIC_DRAW);
  const aPos=gl.getAttribLocation(pr,'aPos'); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);

  const U={}; ['texA','texB','mixAB','resolution','time','mode','wedges','zoom','rot','pan','rAmp','rFreq','rSpeed','imgSpin'].forEach(n=>U[n]=gl.getUniformLocation(pr,n));

  function mkTex(){
    const t=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,t);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.MIRRORED_REPEAT);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.MIRRORED_REPEAT);
    const c=document.createElement('canvas'); c.width=c.height=32; const x=c.getContext('2d');
    x.fillStyle='#333'; x.fillRect(0,0,32,32); x.fillStyle='#777'; x.fillRect(0,0,16,16);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,c);
    return t;
  }
  deckA.tex=mkTex(); deckB.tex=mkTex();

  function upload(deck){
    const src=(deck.vid && !deck.vid.paused && !deck.vid.ended)? deck.vid : deck.img;
    if(!src) return;
    const w=src.videoWidth||src.naturalWidth||src.width, h=src.videoHeight||src.naturalHeight||src.height;
    if(!w||!h) return;
    deck.cvs.width=w; deck.cvs.height=h;
    (deck.ctx||=deck.cvs.getContext('2d')).drawImage(src,0,0,w,h);
    gl.bindTexture(gl.TEXTURE_2D, deck.tex);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,deck.cvs);
  }

  // gestures: 1-finger pan, 2-finger pinch+twist (touch+mouse)
  const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
  const pts = new Map();
  let baseline = { panx:0,pany:0, zoom:1, rot:0, cX:0,cY:0, dist:0, ang:0 };
  function centroid(){ let sx=0,sy=0; for(const p of pts.values()){sx+=p.x; sy+=p.y} const n=pts.size; return {x:sx/n,y:sy/n,n}; }
  function distAng(){ const it=pts.values(); const a=it.next().value, b=it.next().value; const dx=b.x-a.x, dy=b.y-a.y; return {dist:Math.hypot(dx,dy), ang:Math.atan2(dy,dx)}; }
  function snapshotBaseline(){ baseline.panx=state.panx; baseline.pany=state.pany; baseline.zoom=state.zoom; baseline.rot=state.rot;
    if(pts.size>=2){ const c=centroid(); baseline.cX=c.x; baseline.cY=c.y; const da=distAng(); baseline.dist=da.dist; baseline.ang=da.ang; } }
  function syncUI(){ UI.panx.value=state.panx; UI.pany.value=state.pany; UI.zoom.value=state.zoom; UI.rot.value=state.rot; }

  cv.addEventListener('pointerdown', (e)=>{ cv.setPointerCapture(e.pointerId); pts.set(e.pointerId,{x:e.clientX,y:e.clientY}); snapshotBaseline(); }, {passive:false});
  cv.addEventListener('pointermove', (e)=>{
    if(!pts.has(e.pointerId)) return;
    pts.set(e.pointerId,{x:e.clientX,y:e.clientY});
    const c=centroid();
    if(c.n===1){
      state.panx = clamp(state.panx + (e.movementX/innerWidth)*2, -4, 4);
      state.pany = clamp(state.pany - (e.movementY/innerHeight)*2, -4, 4);
      syncUI();
    } else if (c.n>=2){
      const {dist, ang} = distAng();
      const scale = baseline.dist ? (dist / baseline.dist) : 1;
      state.zoom = clamp(baseline.zoom * scale, +UI.zoom.min || 0.2, +UI.zoom.max || 6);
      let dAng = ang - baseline.ang;
      if (dAng > Math.PI)  dAng -= 2*Math.PI;
      if (dAng < -Math.PI) dAng += 2*Math.PI;
      state.rot = clamp(baseline.rot + dAng, +UI.rot.min || -Math.PI, +UI.rot.max || Math.PI);
      state.panx = clamp(baseline.panx + ((c.x - baseline.cX)/innerWidth)*2, -4, 4);
      state.pany = clamp(baseline.pany - ((c.y - baseline.cY)/innerHeight)*2, -4, 4);
      syncUI();
    }
    e.preventDefault();
  }, {passive:false});
  function up(e){ pts.delete(e.pointerId); if(pts.size>0) snapshotBaseline(); }
  cv.addEventListener('pointerup', up, {passive:false});
  cv.addEventListener('pointercancel', up, {passive:false});
  cv.addEventListener('pointerleave', up, {passive:false});

  // rendering loop
  let t0=performance.now();
  function draw(){
    fit();
    upload(deckA); upload(deckB);
    gl.useProgram(pr);

    gl.uniform1i(U.texA,0); gl.uniform1i(U.texB,1);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, deckA.tex);
    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, deckB.tex);

    gl.uniform2f(U.resolution, cv.width, cv.height);
    const t=(performance.now()-t0)/1000.0;
    gl.uniform1f(U.time, t);
    gl.uniform1i(U.mode, state.mode);
    gl.uniform1f(U.wedges, state.wedges);
    gl.uniform1f(U.zoom, state.zoom);
    gl.uniform1f(U.rot, state.rot);
    gl.uniform2f(U.pan, state.panx, state.pany);
    gl.uniform1f(U.rAmp, state.rAmp);
    gl.uniform1f(U.rFreq, state.rFreq);
    gl.uniform1f(U.rSpeed, state.rSpeed);
    gl.uniform1f(U.imgSpin, state.spinHz * 6.28318530718 * t);
    gl.uniform1f(U.mixAB, state.mix);

    gl.viewport(0,0,cv.width,cv.height);
    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(draw);
  }
  draw();

  /* ===== Snapshot and Recording (video/webm, no audio) ===== */
  // Snapshot (PNG) ‚Äî note: CORS applies if external images/videos lack headers
  UI.snap.addEventListener('click', ()=>{
    try{
      const url = cv.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = URL.createObjectURL((()=>{const b64=url.split(',')[1]; const bin=atob(b64); const arr=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++)arr[i]=bin.charCodeAt(i); return new Blob([arr],{type:'image/png'});})());
      a.download = 'kaleidoscope.png'; a.click();
    }catch(e){
      alert('Snapshot failed (likely CORS on external media).');
    }
  });

  // Record WEBM (canvas only)
  let stream=null, rec=null, chunks=[];
  function ensureStream(){ if(!stream && cv.captureStream) stream=cv.captureStream(60); return !!stream; }
  UI.rec.addEventListener('click', ()=>{
    if(!('MediaRecorder' in window)) return alert('MediaRecorder not supported.');
    if(!ensureStream()) return alert('canvas.captureStream not supported.');
    chunks=[];
    try{ rec = new MediaRecorder(stream,{mimeType:'video/webm;codecs=vp9'}); }catch{ rec = new MediaRecorder(stream); }
    rec.ondataavailable = e=>{ if(e.data && e.data.size) chunks.push(e.data); };
    rec.onstop = ()=>{
      const blob = new Blob(chunks, { type:'video/webm' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob); a.download='kaleidoscope.webm'; a.click();
      chunks=[];
      UI.recLamp.style.background='#193b30';
    };
    rec.start();
    UI.recLamp.style.background='#ff445f';
    // tap again to stop
    const stopOnce = ()=>{
      try{ if(rec && rec.state!=='inactive') rec.stop(); }catch{}
      document.removeEventListener('keydown', escStop);
      UI.rec.removeEventListener('click', stopOnce, {once:true});
    };
    function escStop(e){ if(e.key==='Escape') stopOnce(); }
    document.addEventListener('keydown', escStop);
    UI.rec.addEventListener('click', stopOnce, {once:true});
  });
})();
</script>
</body>
</html>
